// Generated by CoffeeScript 1.9.1
var Miki, _, cheerio, fs, moment, phantom, redis, redisModule, rooms, schedules;

redisModule = require('redis');

phantom = require('phantom');

_ = require('underscore');

cheerio = require('cheerio');

fs = require('fs');

moment = require('moment');

schedules = [];

rooms = [];

redis = {};

Miki = (function() {
  var channels;

  function Miki(config) {
    this.config = config;
    console.log("redis server: " + this.config.redis_host + ":" + this.config.redis_port);
    redis = redisModule.createClient(this.config.redis_port, this.config.redis_host);
    redis.lrange([this.config.scheduleKey, 0, -1], function(err, replies) {
      var j, len, r, results, s;
      results = [];
      for (j = 0, len = replies.length; j < len; j++) {
        r = replies[j];
        s = JSON.parse(r);
        results.push(schedules.push(s));
      }
      return results;
    });

    /*
      generate schedule pic
     */
    this.generaterTimer = void 0;
    this.generater = (function(_this) {
      return function() {
        var headlessUrl;
        headlessUrl = "http://" + _this.config.host + ":" + _this.config.port + "/" + _this.config.headless;
        return phantom.create(function(ph) {
          return ph.createPage(function(page) {
            return page.open(headlessUrl, function(status) {
              page.render('static_content/schedule.png');
              console.log("Output on " + new Date());
              return ph.exit();
            });
          });
        });
      };
    })(this);
  }

  Miki.prototype.generatePic = function() {
    clearTimeout(this.generaterTimer);
    return this.generaterTimer = setTimeout(this.generater, 5000);
  };

  Miki.prototype.getSchedules = function() {
    return schedules;
  };

  Miki.prototype.setSchedule = function(schedule) {
    var found, i, j, l, ref, ref1, ret, s;
    found = false;
    for (i = j = 0, ref = schedules.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      s = schedules[i];
      if (s.order === schedule.order) {
        s.begin = schedule.begin;
        s.end = schedule.end;
        s.description = schedule.description;
        found = true;
        break;
      }
    }
    if (!found) {
      schedules.push(schedule);
    }
    ret = [];
    redis.del(this.config.scheduleKey);
    for (i = l = 0, ref1 = schedules.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
      s = schedules[i];
      if (s.begin.length === 0 && s.end.length === 0 && s.description.length === 0) {

      } else {
        s.order = i + 1;
        ret.push(s);
        redis.rpush(this.config.scheduleKey, JSON.stringify(s));
      }
    }
    redis.ltrim(this.config.scheduleKey, 0, ret.length - 1);
    schedules = ret;
    this.generatePic();
    return schedules;
  };

  Miki.prototype.getSchedule = function(callback) {
    console.log("in get schedule");
    return redis.keys('programme:*', function(err, replies) {
      var remains, schedule;
      remains = replies.length;
      schedule = [];
      return replies.map(function(key) {
        return redis.hgetall(key, function(err, replies) {
          var ret;
          schedule.push(replies);
          console.log("remains: " + remains + "  key: " + key);
          if (--remains === 0) {
            ret = _.sortBy(schedule, 'start').toArray();
            console.log(ret);
            return callback(ret);
          }
        });
      });
    });
  };

  Miki.prototype.getRooms = function() {
    return rooms;
  };

  Miki.prototype.updateRoom = function(room) {
    var roomExisted;
    roomExisted = _.find(rooms, function(r) {
      return r.room_id === room.room_id;
    });
    if (roomExisted != null) {
      roomExisted.show_status = room.show_status;
      roomExisted.room_name = room.room_name;
      return roomExisted.show_time = room.show_time;
    } else {
      return rooms.push(room);
    }
  };

  Miki.prototype.createRequestOptions = function(url, host) {
    var headers, options;
    headers = {
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      'Accept-Encoding': 'gzip, deflate, sdch',
      'Accept-Language': 'en-US,en;q=0.8',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Host': host,
      'Pragma': 'no-cache',
      'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.2 Safari/537.36'
    };
    options = {
      url: url,
      headers: headers,
      gzip: true,
      agent: false,
      timeout: 7000
    };
    console.log("REQUEST: " + url);
    return options;
  };

  channels = {
    'tbs': 'TBS',
    'tbs-bs': 'BS-TBS',
    'tbs-1': 'TBSチャンネル1',
    'ntv': '日本テレビ',
    'ntv-bs': 'BS日テレ',
    'ntv-plus': '日テレプラス',
    'nhk-variety': 'NHK総合',
    'nhk-e-1': 'NHK Eテレ1',
    'nhk-bs-perm': 'NHK BSプレミアム',
    'assashi': 'テレビ朝日',
    'asashi-bs': 'BS朝日',
    'tokyo': 'テレビ東京',
    'tokyo-mx-1': 'TOKYO MX1',
    'fuji': 'フジテレビ',
    'j-sports-3': 'J SPORTS 3',
    'fami-geki': 'ファミリー劇場',
    'chiba': 'チバテレ',
    'green': 'グリーンチャンネル'
  };

  Miki.prototype.parseProgramme = function(text, template) {
    var channelFound, k, match, ret, v;
    ret = {
      type: 'unknow',
      year: template.year,
      month: -1,
      day: -1,
      start: '',
      end: '',
      channel: '',
      channelId: '',
      title: '',
      episode: '',
      members: ''
    };
    match = text.match(/(\d+)月(\d+)日（\S）/);
    if (match != null) {
      ret.type = 'date';
      ret.month = match[1];
      ret.day = match[2];
      return ret;
    }
    match = text.match(/(\S+)～(\S+)\s(.*)\s『(.*)』(\s#\d+)?(\s.*)?/);
    if (match != null) {
      ret.month = template.month;
      ret.day = template.day;
      ret.type = 'programme';
      ret.start = match[1];
      ret.end = match[2];
      ret.channel = match[3];
      ret.title = match[4];
      ret.episode = (match[5] || '').trim();
      ret.members = (match[6] || '').trim();
      channelFound = false;
      for (k in channels) {
        v = channels[k];
        if (ret.channel === v) {
          ret.channelId = k;
          channelFound = true;
          break;
        }
      }
      if (!channelFound) {
        console.log("ChannelId Not Found: " + ret.channel);
      }
      return ret;
    }
    return ret;
  };

  Miki.prototype.parseSchedule = function(article) {
    var $, dayCount, j, lastTemplate, len, m, ret, schedule, t, text;
    $ = cheerio.load(article.description, {
      decodeEntities: false
    });
    text = $.html().split('<br>');
    m = moment(article.pubdate);
    lastTemplate = {
      year: m.year()
    };
    dayCount = 0;
    schedule = [];
    for (j = 0, len = text.length; j < len; j++) {
      t = text[j];
      if (dayCount === 3) {
        break;
      }
      ret = this.parseProgramme(t, lastTemplate);
      if (ret.type === 'date') {
        dayCount++;
        lastTemplate = ret;
      } else if (ret.type === 'programme') {
        schedule.push(ret);
      }
    }
    return schedule;
  };

  Miki.prototype.getProgrammeKey = function(programme) {
    var key;
    key = "programme:";
    key += programme.month;
    key += ":";
    key += programme.day;
    key += ":";
    key += programme.start;
    key += ":";
    key += programme.channelId;
    return key;
  };

  Miki.prototype.getExpireSeconds = function(programme) {
    var countdown, currentMoment, endMoment, hour, hourOverflow, minute, offset, timeParts, timeString;
    offset = 3600;
    timeParts = programme.end.split(':');
    hour = timeParts[0];
    minute = timeParts[1];
    if (hour >= 24) {
      hourOverflow = true;
      hour -= 24;
    } else {
      hourOverflow = false;
    }
    timeString = programme.year + " " + programme.month + " " + programme.day + " " + hour + " " + minute + " +0900";
    console.log("source* " + timeString);
    endMoment = moment(timeString, 'YYYY MM DD HH mm Z');
    if (hourOverflow) {
      endMoment.add(1, 'day');
    }
    console.log("end* " + endMoment.format('YYYY M D H m Z'));
    currentMoment = moment();
    countdown = endMoment.diff(currentMoment, 'second') + offset;
    return countdown;
  };

  Miki.prototype.updateSchedule = function(article) {
    var countdown, j, key, len, p, results, schedule;
    console.log("in updateSchedule");
    schedule = this.parseSchedule(article);
    fs.writeFileSync('./out.json', JSON.stringify(schedule, null, 2));
    console.log("schedule parse done");
    results = [];
    for (j = 0, len = schedule.length; j < len; j++) {
      p = schedule[j];
      console.log(JSON.stringify(p));
      key = this.getProgrammeKey(p);
      countdown = this.getExpireSeconds(p);
      console.log("key: " + key);
      console.log(p);
      console.log("countdown: " + countdown);
      redis.hmset(key, p);
      results.push(redis.expire(key, countdown));
    }
    return results;
  };

  return Miki;

})();

module.exports = Miki;
