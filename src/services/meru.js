// Generated by CoffeeScript 1.9.3
var FeedParser, Tashima, _, cheerio, moment, redisModule, request;

request = require('request');

_ = require('underscore');

moment = require('moment');

cheerio = require('cheerio');

FeedParser = require('feedparser');

redisModule = require('redis');

Tashima = (function() {
  function Tashima(miki) {
    this.miki = miki;
    this.redis = redisModule.createClient(this.miki.config.redis_port, this.miki.config.redis_host);
    this.schedule = [];
    this.loadSchedule();
  }

  Tashima.prototype.channels = {
    'tbs': 'TBS',
    'tbs-bs': 'BS-TBS',
    'tbs-1': 'TBSチャンネル1',
    'ntv': '日本テレビ',
    'ntv-bs': 'BS日テレ',
    'ntv-plus': '日テレプラス',
    'nhk-variety': 'NHK総合',
    'nhk-e-1': 'NHK Eテレ1',
    'nhk-bs-perm': 'NHK BSプレミアム',
    'asashi': 'テレビ朝日',
    'asashi-bs': 'BS朝日',
    'tokyo': 'テレビ東京',
    'tokyo-mx-1': 'TOKYO MX1',
    'fuji': 'フジテレビ',
    'j-sports-3': 'J SPORTS 3',
    'fami-geki': 'ファミリー劇場',
    'chiba': 'チバテレ',
    'green': 'グリーンチャンネル',
    'lala': 'LaLa TV',
    'wowow-prime': 'WOWOWプライム',
    'musicontv': 'MUSIC ON! TV'
  };

  Tashima.prototype.parseSchedule = function(article) {
    var $, dayCount, existedKeys, filteredSchedule, i, j, lastTemplate, len, len1, m, p, programmeList, ret, t, text;
    $ = cheerio.load(article.description, {
      decodeEntities: false
    });
    text = $.html().split('<br>');
    m = moment(article.pubdate);
    lastTemplate = {
      year: m.year()
    };
    dayCount = 0;
    programmeList = [];
    for (i = 0, len = text.length; i < len; i++) {
      t = text[i];
      if (dayCount === 3) {
        break;
      }
      ret = this.parseProgramme(t, lastTemplate);
      if (ret.type === 'date') {
        dayCount++;
        lastTemplate = ret;
      } else if (ret.type === 'programme') {
        this.assertOrderKey(ret);
        this.assertProgrammeKey(ret);
        programmeList.push(ret);
      }
    }
    existedKeys = _.pluck(this.schedule, 'key');
    filteredSchedule = _.filter(programmeList, function(p) {
      ret = !_.contains(existedKeys, p.key);
      return ret;
    });
    for (j = 0, len1 = filteredSchedule.length; j < len1; j++) {
      p = filteredSchedule[j];
      this.saveProgramme(p);
    }
    return this.loadSchedule();
  };

  Tashima.prototype.parseProgramme = function(text, template) {
    var channelFound, k, match, ref, ret, v;
    ret = {
      type: 'unknow',
      year: template.year,
      month: -1,
      day: -1,
      start: '',
      end: '',
      channel: '',
      channelId: '',
      title: '',
      episode: '',
      members: '',
      orderKey: '',
      roomId: '',
      roomTitle: ''
    };
    match = text.match(/(\d+)月(\d+)日（\S）/);
    if (match != null) {
      ret.type = 'date';
      ret.month = match[1];
      ret.day = match[2];
      return ret;
    }
    match = text.match(/(\S+)～(\S+)\s(.*)\s『(.*)』(\s#\d+)?(\s.*)?/);
    if (match != null) {
      ret.month = template.month;
      ret.day = template.day;
      ret.type = 'programme';
      ret.start = match[1];
      ret.end = match[2];
      ret.channel = match[3];
      ret.title = match[4];
      ret.episode = (match[5] || '').trim();
      ret.members = (match[6] || '').trim();
      channelFound = false;
      ref = this.channels;
      for (k in ref) {
        v = ref[k];
        if (ret.channel === v) {
          ret.channelId = k;
          channelFound = true;
          break;
        }
      }
      if (!channelFound) {
        console.log("ChannelId Not Found: " + ret.channel);
      }
      return ret;
    }
    return ret;
  };

  Tashima.prototype.assertOrderKey = function(programme) {
    var orderKey;
    orderKey = programme.year;
    orderKey += (programme.month.length === 2 ? programme.month : "0" + programme.month);
    orderKey += (programme.day.length === 2 ? programme.day : "0" + programme.day);
    orderKey += programme.start;
    return programme.orderKey = orderKey;
  };

  Tashima.prototype.assertProgrammeKey = function(programme) {
    var key;
    key = "programme:";
    key += programme.month;
    key += ":";
    key += programme.day;
    key += ":";
    key += programme.start;
    key += ":";
    key += programme.channelId;
    return programme.key = key;
  };

  Tashima.prototype.getExpireSeconds = function(programme) {
    var countdown, currentMoment, endMoment, hour, hourOverflow, minute, offset, timeParts, timeString;
    offset = this.miki.config.expireOffset;
    timeParts = programme.end.split(':');
    hour = timeParts[0];
    minute = timeParts[1];
    if (hour >= 24) {
      hourOverflow = true;
      hour -= 24;
    } else {
      hourOverflow = false;
    }
    timeString = programme.year + " " + programme.month + " " + programme.day + " " + hour + " " + minute + " +0900";
    endMoment = moment(timeString, 'YYYY MM DD HH mm Z');
    if (hourOverflow) {
      endMoment.add(1, 'day');
    }
    currentMoment = moment();
    countdown = endMoment.diff(currentMoment, 'second') + offset;
    return countdown;
  };

  Tashima.prototype.saveProgramme = function(programme) {
    var countdown;
    countdown = this.getExpireSeconds(programme);
    console.log("save key: " + programme.key);
    this.redis.hmset(programme.key, programme);
    return this.redis.expire(programme.key, countdown);
  };

  Tashima.prototype.loadSchedule = function() {
    var self;
    this.schedule = [];
    self = this;
    return this.redis.keys('programme:*', function(err, replies) {
      var remains;
      remains = replies.length;
      return replies.map(function(key) {
        return self.redis.hgetall(key, function(err, replies) {
          self.schedule.push(replies);
          if (--remains === 0) {
            console.log("[miki] finish load schedule, saving...");
            self.schedule = _.sortBy(self.schedule, 'orderKey');
            return self.miki.updateSchedule(self.schedule);
          }
        });
      });
    });
  };

  Tashima.prototype.startService = function() {
    var checker, feedparser, getTopArticle, req, self, url;
    self = this;
    url = self.miki.config.scheduleFetchRssUrl;
    req = request(url);
    feedparser = new FeedParser();
    getTopArticle = function() {
      var article;
      article = this.read();
      console.log("parsing date: " + article.title);
      feedparser.removeListener('readable', getTopArticle);
      return self.parseSchedule(article);
    };
    req.on('response', function(res) {
      if (res.statusCode !== 200) {
        return this.emit('error', new Error('Bad status code'));
      }
      return this.pipe(feedparser);
    });
    feedparser.on('readable', getTopArticle);
    return checker = function(rss) {
      return setTimeout(checker, this.miki.config.scheduleCheckInterval);
    };
  };

  return Tashima;

})();

module.exports = Tashima;
