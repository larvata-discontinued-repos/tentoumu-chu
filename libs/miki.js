// Generated by CoffeeScript 1.6.3
var Miki, phantom, redis, redisModule, rooms, schedules, _;

redisModule = require('redis');

phantom = require('phantom');

_ = require('underscore');

schedules = [];

rooms = [];

redis = {};

Miki = (function() {
  function Miki(config) {
    this.config = config;
    console.log("redis server: " + this.config.redis_host + ":" + this.config.redis_port);
    redis = redisModule.createClient(this.config.redis_port, this.config.redis_host);
    redis.lrange([this.config.scheduleKey, 0, -1], function(err, replies) {
      var r, s, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = replies.length; _i < _len; _i++) {
        r = replies[_i];
        s = JSON.parse(r);
        _results.push(schedules.push(s));
      }
      return _results;
    });
    this.generaterTimer = void 0;
    this.generater = (function(_this) {
      return function() {
        var headlessUrl;
        headlessUrl = "http://" + _this.config.host + ":" + _this.config.port + "/" + _this.config.headless;
        return phantom.create(function(ph) {
          return ph.createPage(function(page) {
            return page.open(headlessUrl, function(status) {
              page.render('static_content/schedule.png');
              console.log("Output on " + new Date());
              return ph.exit();
            });
          });
        });
      };
    })(this);
  }

  Miki.prototype.getSchedules = function() {
    return schedules;
  };

  Miki.prototype.setSchedule = function(schedule) {
    var found, i, ret, s, _i, _j, _ref, _ref1;
    found = false;
    for (i = _i = 0, _ref = schedules.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      s = schedules[i];
      if (s.order === schedule.order) {
        s.begin = schedule.begin;
        s.end = schedule.end;
        s.description = schedule.description;
        found = true;
        break;
      }
    }
    if (!found) {
      schedules.push(schedule);
    }
    ret = [];
    redis.del(this.config.scheduleKey);
    for (i = _j = 0, _ref1 = schedules.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      s = schedules[i];
      if (s.begin.length === 0 && s.end.length === 0 && s.description.length === 0) {

      } else {
        s.order = i + 1;
        ret.push(s);
        redis.rpush(this.config.scheduleKey, JSON.stringify(s));
      }
    }
    redis.ltrim(this.config.scheduleKey, 0, ret.length - 1);
    schedules = ret;
    this.generatePic();
    return schedules;
  };

  Miki.prototype.generatePic = function() {
    clearTimeout(this.generaterTimer);
    return this.generaterTimer = setTimeout(this.generater, 5000);
  };

  Miki.prototype.getRooms = function() {
    return rooms;
  };

  Miki.prototype.updateRoom = function(room) {
    var roomExisted;
    roomExisted = _.find(rooms, function(r) {
      return r.room_id === room.room_id;
    });
    if (roomExisted != null) {
      roomExisted.show_status = room.show_status;
      roomExisted.room_name = room.room_name;
      return roomExisted.show_time = room.show_time;
    } else {
      return rooms.push(room);
    }
  };

  return Miki;

})();

module.exports = Miki;
